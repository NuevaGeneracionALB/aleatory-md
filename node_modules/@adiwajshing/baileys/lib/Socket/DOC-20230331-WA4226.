"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeMessagesSocket = void 0;
var boom_1 = require("@hapi/boom");
var node_cache_1 = require("node-cache");
var WAProto_1 = require("../../WAProto");
var Defaults_1 = require("../Defaults");
var Utils_1 = require("../Utils");
var link_preview_1 = require("../Utils/link-preview");
var WABinary_1 = require("../WABinary");
var groups_1 = require("./groups");
var ListType = WAProto_1.proto.Message.ListMessage.ListType;
var makeMessagesSocket = function (config) {
    var logger = config.logger, linkPreviewImageThumbnailWidth = config.linkPreviewImageThumbnailWidth, generateHighQualityLinkPreview = config.generateHighQualityLinkPreview, axiosOptions = config.options, patchMessageBeforeSending = config.patchMessageBeforeSending;
    var sock = (0, groups_1.makeGroupsSocket)(config);
    var ev = sock.ev, authState = sock.authState, processingMutex = sock.processingMutex, signalRepository = sock.signalRepository, upsertMessage = sock.upsertMessage, query = sock.query, fetchPrivacySettings = sock.fetchPrivacySettings, generateMessageTag = sock.generateMessageTag, sendNode = sock.sendNode, groupMetadata = sock.groupMetadata, groupToggleEphemeral = sock.groupToggleEphemeral;
    var userDevicesCache = config.userDevicesCache || new node_cache_1.default({
        stdTTL: Defaults_1.DEFAULT_CACHE_TTLS.USER_DEVICES,
        useClones: false
    });
    var mediaConn;
    var refreshMediaConn = function (forceGet) {
        if (forceGet === void 0) { forceGet = false; }
        return __awaiter(void 0, void 0, void 0, function () {
            var media;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, mediaConn];
                    case 1:
                        media = _a.sent();
                        if (!media || forceGet || (new Date().getTime() - media.fetchDate.getTime()) > media.ttl * 1000) {
                            mediaConn = (function () { return __awaiter(void 0, void 0, void 0, function () {
                                var result, mediaConnNode, node;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, query({
                                                tag: 'iq',
                                                attrs: {
                                                    type: 'set',
                                                    xmlns: 'w:m',
                                                    to: WABinary_1.S_WHATSAPP_NET,
                                                },
                                                content: [{ tag: 'media_conn', attrs: {} }]
                                            })];
                                        case 1:
                                            result = _a.sent();
                                            mediaConnNode = (0, WABinary_1.getBinaryNodeChild)(result, 'media_conn');
                                            node = {
                                                hosts: (0, WABinary_1.getBinaryNodeChildren)(mediaConnNode, 'host').map(function (_a) {
                                                    var attrs = _a.attrs;
                                                    return ({
                                                        hostname: attrs.hostname,
                                                        maxContentLengthBytes: +attrs.maxContentLengthBytes,
                                                    });
                                                }),
                                                auth: mediaConnNode.attrs.auth,
                                                ttl: +mediaConnNode.attrs.ttl,
                                                fetchDate: new Date()
                                            };
                                            logger.debug('fetched media conn');
                                            return [2 /*return*/, node];
                                    }
                                });
                            }); })();
                        }
                        return [2 /*return*/, mediaConn];
                }
            });
        });
    };
    /**
     * generic send receipt function
     * used for receipts of phone call, read, delivery etc.
     * */
    var sendReceipt = function (jid, participant, messageIds, type) { return __awaiter(void 0, void 0, void 0, function () {
        var node, isReadReceipt, remainingMessageIds;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    node = {
                        tag: 'receipt',
                        attrs: {
                            id: messageIds[0],
                        },
                    };
                    isReadReceipt = type === 'read' || type === 'read-self';
                    if (isReadReceipt) {
                        node.attrs.t = (0, Utils_1.unixTimestampSeconds)().toString();
                    }
                    if (type === 'sender' && (0, WABinary_1.isJidUser)(jid)) {
                        node.attrs.recipient = jid;
                        node.attrs.to = participant;
                    }
                    else {
                        node.attrs.to = jid;
                        if (participant) {
                            node.attrs.participant = participant;
                        }
                    }
                    if (type) {
                        node.attrs.type = type;
                    }
                    remainingMessageIds = messageIds.slice(1);
                    if (remainingMessageIds.length) {
                        node.content = [
                            {
                                tag: 'list',
                                attrs: {},
                                content: remainingMessageIds.map(function (id) { return ({
                                    tag: 'item',
                                    attrs: { id: id }
                                }); })
                            }
                        ];
                    }
                    logger.debug({ attrs: node.attrs, messageIds: messageIds }, 'sending receipt for messages');
                    return [4 /*yield*/, sendNode(node)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); };
    /** Correctly bulk send receipts to multiple chats, participants */
    var sendReceipts = function (keys, type) { return __awaiter(void 0, void 0, void 0, function () {
        var recps, _i, recps_1, _a, jid, participant, messageIds;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    recps = (0, Utils_1.aggregateMessageKeysNotFromMe)(keys);
                    _i = 0, recps_1 = recps;
                    _b.label = 1;
                case 1:
                    if (!(_i < recps_1.length)) return [3 /*break*/, 4];
                    _a = recps_1[_i], jid = _a.jid, participant = _a.participant, messageIds = _a.messageIds;
                    return [4 /*yield*/, sendReceipt(jid, participant, messageIds, type)];
                case 2:
                    _b.sent();
                    _b.label = 3;
                case 3:
                    _i++;
                    return [3 /*break*/, 1];
                case 4: return [2 /*return*/];
            }
        });
    }); };
    /** Bulk read messages. Keys can be from different chats & participants */
    var readMessages = function (keys) { return __awaiter(void 0, void 0, void 0, function () {
        var privacySettings, readType;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fetchPrivacySettings()
                    // based on privacy settings, we have to change the read type
                ];
                case 1:
                    privacySettings = _a.sent();
                    readType = privacySettings.readreceipts === 'all' ? 'read' : 'read-self';
                    return [4 /*yield*/, sendReceipts(keys, readType)];
                case 2:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); };
    /** Fetch all the devices we've to send a message to */
    var getUSyncDevices = function (jids, useCache, ignoreZeroDevices) { return __awaiter(void 0, void 0, void 0, function () {
        var deviceResults, users, _i, jids_1, jid, user, devices, iq, result, extracted, deviceMap, _a, extracted_1, item, key;
        var _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    deviceResults = [];
                    if (!useCache) {
                        logger.debug('not using cache for devices');
                    }
                    users = [];
                    jids = Array.from(new Set(jids));
                    for (_i = 0, jids_1 = jids; _i < jids_1.length; _i++) {
                        jid = jids_1[_i];
                        user = (_b = (0, WABinary_1.jidDecode)(jid)) === null || _b === void 0 ? void 0 : _b.user;
                        jid = (0, WABinary_1.jidNormalizedUser)(jid);
                        devices = userDevicesCache.get(user);
                        if (devices && useCache) {
                            deviceResults.push.apply(deviceResults, devices);
                            logger.trace({ user: user }, 'using cache for devices');
                        }
                        else {
                            users.push({ tag: 'user', attrs: { jid: jid } });
                        }
                    }
                    iq = {
                        tag: 'iq',
                        attrs: {
                            to: WABinary_1.S_WHATSAPP_NET,
                            type: 'get',
                            xmlns: 'usync',
                        },
                        content: [
                            {
                                tag: 'usync',
                                attrs: {
                                    sid: generateMessageTag(),
                                    mode: 'query',
                                    last: 'true',
                                    index: '0',
                                    context: 'message',
                                },
                                content: [
                                    {
                                        tag: 'query',
                                        attrs: {},
                                        content: [
                                            {
                                                tag: 'devices',
                                                attrs: { version: '2' }
                                            }
                                        ]
                                    },
                                    { tag: 'list', attrs: {}, content: users }
                                ]
                            },
                        ],
                    };
                    return [4 /*yield*/, query(iq)];
                case 1:
                    result = _c.sent();
                    extracted = (0, Utils_1.extractDeviceJids)(result, authState.creds.me.id, ignoreZeroDevices);
                    deviceMap = {};
                    for (_a = 0, extracted_1 = extracted; _a < extracted_1.length; _a++) {
                        item = extracted_1[_a];
                        deviceMap[item.user] = deviceMap[item.user] || [];
                        deviceMap[item.user].push(item);
                        deviceResults.push(item);
                    }
                    for (key in deviceMap) {
                        userDevicesCache.set(key, deviceMap[key]);
                    }
                    return [2 /*return*/, deviceResults];
            }
        });
    }); };
    var assertSessions = function (jids, force) { return __awaiter(void 0, void 0, void 0, function () {
        var didFetchNewSession, jidsRequiringFetch, addrs, sessions, _i, jids_2, jid, signalId, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    didFetchNewSession = false;
                    jidsRequiringFetch = [];
                    if (!force) return [3 /*break*/, 1];
                    jidsRequiringFetch = jids;
                    return [3 /*break*/, 3];
                case 1:
                    addrs = jids.map(function (jid) { return (signalRepository
                        .jidToSignalProtocolAddress(jid)); });
                    return [4 /*yield*/, authState.keys.get('session', addrs)];
                case 2:
                    sessions = _a.sent();
                    for (_i = 0, jids_2 = jids; _i < jids_2.length; _i++) {
                        jid = jids_2[_i];
                        signalId = signalRepository
                            .jidToSignalProtocolAddress(jid);
                        if (!sessions[signalId]) {
                            jidsRequiringFetch.push(jid);
                        }
                    }
                    _a.label = 3;
                case 3:
                    if (!jidsRequiringFetch.length) return [3 /*break*/, 6];
                    logger.debug({ jidsRequiringFetch: jidsRequiringFetch }, 'fetching sessions');
                    return [4 /*yield*/, query({
                            tag: 'iq',
                            attrs: {
                                xmlns: 'encrypt',
                                type: 'get',
                                to: WABinary_1.S_WHATSAPP_NET,
                            },
                            content: [
                                {
                                    tag: 'key',
                                    attrs: {},
                                    content: jidsRequiringFetch.map(function (jid) { return ({
                                        tag: 'user',
                                        attrs: { jid: jid },
                                    }); })
                                }
                            ]
                        })];
                case 4:
                    result = _a.sent();
                    return [4 /*yield*/, (0, Utils_1.parseAndInjectE2ESessions)(result, signalRepository)];
                case 5:
                    _a.sent();
                    didFetchNewSession = true;
                    _a.label = 6;
                case 6: return [2 /*return*/, didFetchNewSession];
            }
        });
    }); };
    var createParticipantNodes = function (jids, message, extraAttrs) { return __awaiter(void 0, void 0, void 0, function () {
        var patched, bytes, shouldIncludeDeviceIdentity, nodes;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, patchMessageBeforeSending(message, jids)];
                case 1:
                    patched = _a.sent();
                    bytes = (0, Utils_1.encodeWAMessage)(patched);
                    shouldIncludeDeviceIdentity = false;
                    return [4 /*yield*/, Promise.all(jids.map(function (jid) { return __awaiter(void 0, void 0, void 0, function () {
                            var _a, type, ciphertext, node;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0: return [4 /*yield*/, signalRepository
                                            .encryptMessage({ jid: jid, data: bytes })];
                                    case 1:
                                        _a = _b.sent(), type = _a.type, ciphertext = _a.ciphertext;
                                        if (type === 'pkmsg') {
                                            shouldIncludeDeviceIdentity = true;
                                        }
                                        node = {
                                            tag: 'to',
                                            attrs: { jid: jid },
                                            content: [{
                                                    tag: 'enc',
                                                    attrs: __assign({ v: '2', type: type }, extraAttrs || {}),
                                                    content: ciphertext
                                                }]
                                        };
                                        return [2 /*return*/, node];
                                }
                            });
                        }); }))];
                case 2:
                    nodes = _a.sent();
                    return [2 /*return*/, { nodes: nodes, shouldIncludeDeviceIdentity: shouldIncludeDeviceIdentity }];
            }
        });
    }); };
    var relayMessage = function (jid, message, _a) {
        var msgId = _a.messageId, participant = _a.participant, additionalAttributes = _a.additionalAttributes, useUserDevicesCache = _a.useUserDevicesCache, cachedGroupMetadata = _a.cachedGroupMetadata;
        return __awaiter(void 0, void 0, void 0, function () {
            var meId, shouldIncludeDeviceIdentity, _b, user, server, isGroup, participants, destinationJid, binaryNodeContent, devices, meMsg, _c, user_1, device;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        meId = authState.creds.me.id;
                        shouldIncludeDeviceIdentity = false;
                        _b = (0, WABinary_1.jidDecode)(jid), user = _b.user, server = _b.server;
                        isGroup = server === 'g.us';
                        msgId = msgId || (0, Utils_1.generateMessageID)();
                        useUserDevicesCache = useUserDevicesCache !== false;
                        participants = [];
                        destinationJid = (0, WABinary_1.jidEncode)(user, isGroup ? 'g.us' : 's.whatsapp.net');
                        binaryNodeContent = [];
                        devices = [];
                        meMsg = {
                            deviceSentMessage: {
                                destinationJid: destinationJid,
                                message: message
                            }
                        };
                        if (participant) {
                            // when the retry request is not for a group
                            // only send to the specific device that asked for a retry
                            // otherwise the message is sent out to every device that should be a recipient
                            if (!isGroup) {
                                additionalAttributes = __assign(__assign({}, additionalAttributes), { 'device_fanout': 'false' });
                            }
                            _c = (0, WABinary_1.jidDecode)(participant.jid), user_1 = _c.user, device = _c.device;
                            devices.push({ user: user_1, device: device });
                        }
                        return [4 /*yield*/, authState.keys.transaction(function () { return __awaiter(void 0, void 0, void 0, function () {
                                var mediaType, _a, groupData, senderKeyMap, participantsList, additionalDevices, patched, bytes, _b, ciphertext, senderKeyDistributionMessage, senderKeyJids, _i, devices_1, _c, user_2, device, jid_1, senderKeyMsg, result, meUser, additionalDevices, allJids, meJids, otherJids, _d, devices_2, _e, user_3, device, jid_2, isMe, _f, _g, meNodes, s1, _h, otherNodes, s2, stanza, buttonType;
                                var _j;
                                return __generator(this, function (_k) {
                                    switch (_k.label) {
                                        case 0:
                                            mediaType = getMediaType(message);
                                            if (!isGroup) return [3 /*break*/, 10];
                                            return [4 /*yield*/, Promise.all([
                                                    (function () { return __awaiter(void 0, void 0, void 0, function () {
                                                        var groupData, _a;
                                                        return __generator(this, function (_b) {
                                                            switch (_b.label) {
                                                                case 0:
                                                                    if (!cachedGroupMetadata) return [3 /*break*/, 2];
                                                                    return [4 /*yield*/, cachedGroupMetadata(jid)];
                                                                case 1:
                                                                    _a = _b.sent();
                                                                    return [3 /*break*/, 3];
                                                                case 2:
                                                                    _a = undefined;
                                                                    _b.label = 3;
                                                                case 3:
                                                                    groupData = _a;
                                                                    if (groupData) {
                                                                        logger.trace({ jid: jid, participants: groupData.participants.length }, 'using cached group metadata');
                                                                    }
                                                                    if (!!groupData) return [3 /*break*/, 5];
                                                                    return [4 /*yield*/, groupMetadata(jid)];
                                                                case 4:
                                                                    groupData = _b.sent();
                                                                    _b.label = 5;
                                                                case 5: return [2 /*return*/, groupData];
                                                            }
                                                        });
                                                    }); })(),
                                                    (function () { return __awaiter(void 0, void 0, void 0, function () {
                                                        var result;
                                                        return __generator(this, function (_a) {
                                                            switch (_a.label) {
                                                                case 0:
                                                                    if (!!participant) return [3 /*break*/, 2];
                                                                    return [4 /*yield*/, authState.keys.get('sender-key-memory', [jid])];
                                                                case 1:
                                                                    result = _a.sent();
                                                                    return [2 /*return*/, result[jid] || {}];
                                                                case 2: return [2 /*return*/, {}];
                                                            }
                                                        });
                                                    }); })()
                                                ])];
                                        case 1:
                                            _a = _k.sent(), groupData = _a[0], senderKeyMap = _a[1];
                                            if (!!participant) return [3 /*break*/, 3];
                                            participantsList = groupData.participants.map(function (p) { return p.id; });
                                            return [4 /*yield*/, getUSyncDevices(participantsList, !!useUserDevicesCache, false)];
                                        case 2:
                                            additionalDevices = _k.sent();
                                            devices.push.apply(devices, additionalDevices);
                                            _k.label = 3;
                                        case 3: return [4 /*yield*/, patchMessageBeforeSending(message, devices.map(function (d) { return (0, WABinary_1.jidEncode)(d.user, 's.whatsapp.net', d.device); }))];
                                        case 4:
                                            patched = _k.sent();
                                            bytes = (0, Utils_1.encodeWAMessage)(patched);
                                            return [4 /*yield*/, signalRepository.encryptGroupMessage({
                                                    group: destinationJid,
                                                    data: bytes,
                                                    meId: meId,
                                                })];
                                        case 5:
                                            _b = _k.sent(), ciphertext = _b.ciphertext, senderKeyDistributionMessage = _b.senderKeyDistributionMessage;
                                            senderKeyJids = [];
                                            // ensure a connection is established with every device
                                            for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
                                                _c = devices_1[_i], user_2 = _c.user, device = _c.device;
                                                jid_1 = (0, WABinary_1.jidEncode)(user_2, 's.whatsapp.net', device);
                                                if (!senderKeyMap[jid_1] || !!participant) {
                                                    senderKeyJids.push(jid_1);
                                                    // store that this person has had the sender keys sent to them
                                                    senderKeyMap[jid_1] = true;
                                                }
                                            }
                                            if (!senderKeyJids.length) return [3 /*break*/, 8];
                                            logger.debug({ senderKeyJids: senderKeyJids }, 'sending new sender key');
                                            senderKeyMsg = {
                                                senderKeyDistributionMessage: {
                                                    axolotlSenderKeyDistributionMessage: senderKeyDistributionMessage,
                                                    groupId: destinationJid
                                                }
                                            };
                                            return [4 /*yield*/, assertSessions(senderKeyJids, false)];
                                        case 6:
                                            _k.sent();
                                            return [4 /*yield*/, createParticipantNodes(senderKeyJids, senderKeyMsg, mediaType ? { mediatype: mediaType } : undefined)];
                                        case 7:
                                            result = _k.sent();
                                            shouldIncludeDeviceIdentity = shouldIncludeDeviceIdentity || result.shouldIncludeDeviceIdentity;
                                            participants.push.apply(participants, result.nodes);
                                            _k.label = 8;
                                        case 8:
                                            binaryNodeContent.push({
                                                tag: 'enc',
                                                attrs: { v: '2', type: 'skmsg' },
                                                content: ciphertext
                                            });
                                            return [4 /*yield*/, authState.keys.set({ 'sender-key-memory': (_j = {}, _j[jid] = senderKeyMap, _j) })];
                                        case 9:
                                            _k.sent();
                                            return [3 /*break*/, 15];
                                        case 10:
                                            meUser = (0, WABinary_1.jidDecode)(meId).user;
                                            if (!!participant) return [3 /*break*/, 12];
                                            devices.push({ user: user });
                                            devices.push({ user: meUser });
                                            return [4 /*yield*/, getUSyncDevices([meId, jid], !!useUserDevicesCache, true)];
                                        case 11:
                                            additionalDevices = _k.sent();
                                            devices.push.apply(devices, additionalDevices);
                                            _k.label = 12;
                                        case 12:
                                            allJids = [];
                                            meJids = [];
                                            otherJids = [];
                                            for (_d = 0, devices_2 = devices; _d < devices_2.length; _d++) {
                                                _e = devices_2[_d], user_3 = _e.user, device = _e.device;
                                                jid_2 = (0, WABinary_1.jidEncode)(user_3, 's.whatsapp.net', device);
                                                isMe = user_3 === meUser;
                                                if (isMe) {
                                                    meJids.push(jid_2);
                                                }
                                                else {
                                                    otherJids.push(jid_2);
                                                }
                                                allJids.push(jid_2);
                                            }
                                            return [4 /*yield*/, assertSessions(allJids, false)];
                                        case 13:
                                            _k.sent();
                                            return [4 /*yield*/, Promise.all([
                                                    createParticipantNodes(meJids, meMsg, mediaType ? { mediatype: mediaType } : undefined),
                                                    createParticipantNodes(otherJids, message, mediaType ? { mediatype: mediaType } : undefined)
                                                ])];
                                        case 14:
                                            _f = _k.sent(), _g = _f[0], meNodes = _g.nodes, s1 = _g.shouldIncludeDeviceIdentity, _h = _f[1], otherNodes = _h.nodes, s2 = _h.shouldIncludeDeviceIdentity;
                                            participants.push.apply(participants, meNodes);
                                            participants.push.apply(participants, otherNodes);
                                            shouldIncludeDeviceIdentity = shouldIncludeDeviceIdentity || s1 || s2;
                                            _k.label = 15;
                                        case 15:
                                            if (participants.length) {
                                                binaryNodeContent.push({
                                                    tag: 'participants',
                                                    attrs: {},
                                                    content: participants
                                                });
                                            }
                                            stanza = {
                                                tag: 'message',
                                                attrs: __assign({ id: msgId, type: 'text' }, (additionalAttributes || {})),
                                                content: binaryNodeContent
                                            };
                                            // if the participant to send to is explicitly specified (generally retry recp)
                                            // ensure the message is only sent to that person
                                            // if a retry receipt is sent to everyone -- it'll fail decryption for everyone else who received the msg
                                            if (participant) {
                                                if ((0, WABinary_1.isJidGroup)(destinationJid)) {
                                                    stanza.attrs.to = destinationJid;
                                                    stanza.attrs.participant = participant.jid;
                                                }
                                                else if ((0, WABinary_1.areJidsSameUser)(participant.jid, meId)) {
                                                    stanza.attrs.to = participant.jid;
                                                    stanza.attrs.recipient = destinationJid;
                                                }
                                                else {
                                                    stanza.attrs.to = participant.jid;
                                                }
                                            }
                                            else {
                                                stanza.attrs.to = destinationJid;
                                            }
                                            if (shouldIncludeDeviceIdentity) {
                                                stanza.content.push({
                                                    tag: 'device-identity',
                                                    attrs: {},
                                                    content: (0, Utils_1.encodeSignedDeviceIdentity)(authState.creds.account, true)
                                                });
                                                logger.debug({ jid: jid }, 'adding device identity');
                                            }
                                            buttonType = getButtonType(message);
                                            if (buttonType) {
                                                stanza.content.push({
                                                    tag: 'biz',
                                                    attrs: {},
                                                    content: [
                                                        {
                                                            tag: buttonType,
                                                            attrs: getButtonArgs(message),
                                                        }
                                                    ]
                                                });
                                                logger.debug({ jid: jid }, 'adding business node');
                                            }
                                            logger.debug({ msgId: msgId }, "sending message to ".concat(participants.length, " devices"));
                                            return [4 /*yield*/, sendNode(stanza)];
                                        case 16:
                                            _k.sent();
                                            return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        _d.sent();
                        return [2 /*return*/, msgId];
                }
            });
        });
    };
    var getMediaType = function (message) {
        if (message.imageMessage) {
            return 'image';
        }
        else if (message.videoMessage) {
            return message.videoMessage.gifPlayback ? 'gif' : 'video';
        }
        else if (message.audioMessage) {
            return message.audioMessage.ptt ? 'ptt' : 'audio';
        }
        else if (message.contactMessage) {
            return 'vcard';
        }
        else if (message.documentMessage) {
            return 'document';
        }
        else if (message.contactsArrayMessage) {
            return 'contact_array';
        }
        else if (message.liveLocationMessage) {
            return 'livelocation';
        }
        else if (message.stickerMessage) {
            return 'sticker';
        }
        else if (message.listMessage) {
            return 'list';
        }
        else if (message.listResponseMessage) {
            return 'list_response';
        }
        else if (message.buttonsResponseMessage) {
            return 'buttons_response';
        }
        else if (message.orderMessage) {
            return 'order';
        }
        else if (message.productMessage) {
            return 'product';
        }
        else if (message.interactiveResponseMessage) {
            return 'native_flow_response';
        }
    };
    var getButtonType = function (message) {
        if (message.buttonsMessage) {
            return 'buttons';
        }
        else if (message.buttonsResponseMessage) {
            return 'buttons_response';
        }
        else if (message.interactiveResponseMessage) {
            return 'interactive_response';
        }
        else if (message.listMessage) {
            return 'list';
        }
        else if (message.listResponseMessage) {
            return 'list_response';
        }
    };
    var getButtonArgs = function (message) {
        if (message.templateMessage) {
            // TODO: Add attributes
            return {};
        }
        else if (message.listMessage) {
            var type = message.listMessage.listType;
            if (!type) {
                throw new boom_1.Boom("Expected list type inside message");
            }
            return { v: '2', type: ListType[type].toLowerCase() };
        }
        else {
            return {};
        }
    };
    var getPrivacyTokens = function (jids) { return __awaiter(void 0, void 0, void 0, function () {
        var t, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    t = (0, Utils_1.unixTimestampSeconds)().toString();
                    return [4 /*yield*/, query({
                            tag: 'iq',
                            attrs: {
                                to: WABinary_1.S_WHATSAPP_NET,
                                type: 'set',
                                xmlns: 'privacy'
                            },
                            content: [
                                {
                                    tag: 'tokens',
                                    attrs: {},
                                    content: jids.map(function (jid) { return ({
                                        tag: 'token',
                                        attrs: {
                                            jid: (0, WABinary_1.jidNormalizedUser)(jid),
                                            t: t,
                                            type: 'trusted_contact'
                                        }
                                    }); })
                                }
                            ]
                        })];
                case 1:
                    result = _a.sent();
                    return [2 /*return*/, result];
            }
        });
    }); };
    var waUploadToServer = (0, Utils_1.getWAUploadToServer)(config, refreshMediaConn);
    var waitForMsgMediaUpdate = (0, Utils_1.bindWaitForEvent)(ev, 'messages.media-update');
    return __assign(__assign({}, sock), { getPrivacyTokens: getPrivacyTokens, assertSessions: assertSessions, relayMessage: relayMessage, sendReceipt: sendReceipt, sendReceipts: sendReceipts, readMessages: readMessages, refreshMediaConn: refreshMediaConn, waUploadToServer: waUploadToServer, fetchPrivacySettings: fetchPrivacySettings, updateMediaMessage: function (message) { return __awaiter(void 0, void 0, void 0, function () {
            var content, mediaKey, meId, node, error;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        content = (0, Utils_1.assertMediaContent)(message.message);
                        mediaKey = content.mediaKey;
                        meId = authState.creds.me.id;
                        node = (0, Utils_1.encryptMediaRetryRequest)(message.key, mediaKey, meId);
                        error = undefined;
                        return [4 /*yield*/, Promise.all([
                                sendNode(node),
                                waitForMsgMediaUpdate(function (update) {
                                    var result = update.find(function (c) { return c.key.id === message.key.id; });
                                    if (result) {
                                        if (result.error) {
                                            error = result.error;
                                        }
                                        else {
                                            try {
                                                var media = (0, Utils_1.decryptMediaRetryData)(result.media, mediaKey, result.key.id);
                                                if (media.result !== WAProto_1.proto.MediaRetryNotification.ResultType.SUCCESS) {
                                                    var resultStr = WAProto_1.proto.MediaRetryNotification.ResultType[media.result];
                                                    throw new boom_1.Boom("Media re-upload failed by device (".concat(resultStr, ")"), { data: media, statusCode: (0, Utils_1.getStatusCodeForMediaRetry)(media.result) || 404 });
                                                }
                                                content.directPath = media.directPath;
                                                content.url = (0, Utils_1.getUrlFromDirectPath)(content.directPath);
                                                logger.debug({ directPath: media.directPath, key: result.key }, 'media update successful');
                                            }
                                            catch (err) {
                                                error = err;
                                            }
                                        }
                                        return true;
                                    }
                                })
                            ])];
                    case 1:
                        _a.sent();
                        if (error) {
                            throw error;
                        }
                        ev.emit('messages.update', [
                            { key: message.key, update: { message: message.message } }
                        ]);
                        return [2 /*return*/, message];
                }
            });
        }); }, sendMessage: function (jid, content, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(void 0, void 0, void 0, function () {
                var userJid, disappearingMessagesInChat, value, fullMsg_1, isDeleteMsg, additionalAttributes;
                var _a, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            userJid = authState.creds.me.id;
                            if (!(typeof content === 'object' &&
                                'disappearingMessagesInChat' in content &&
                                typeof content['disappearingMessagesInChat'] !== 'undefined' &&
                                (0, WABinary_1.isJidGroup)(jid))) return [3 /*break*/, 2];
                            disappearingMessagesInChat = content.disappearingMessagesInChat;
                            value = typeof disappearingMessagesInChat === 'boolean' ?
                                (disappearingMessagesInChat ? Defaults_1.WA_DEFAULT_EPHEMERAL : 0) :
                                disappearingMessagesInChat;
                            return [4 /*yield*/, groupToggleEphemeral(jid, value)];
                        case 1:
                            _c.sent();
                            return [3 /*break*/, 5];
                        case 2: return [4 /*yield*/, (0, Utils_1.generateWAMessage)(jid, content, __assign({ logger: logger, userJid: userJid, getUrlInfo: function (text) { return (0, link_preview_1.getUrlInfo)(text, {
                                    thumbnailWidth: linkPreviewImageThumbnailWidth,
                                    fetchOpts: __assign({ timeout: 3000 }, axiosOptions || {}),
                                    logger: logger,
                                    uploadImage: generateHighQualityLinkPreview
                                        ? waUploadToServer
                                        : undefined
                                }); }, upload: waUploadToServer, mediaCache: config.mediaCache, options: config.options }, options))];
                        case 3:
                            fullMsg_1 = _c.sent();
                            isDeleteMsg = 'delete' in content && !!content.delete;
                            additionalAttributes = {};
                            // required for delete
                            if (isDeleteMsg) {
                                // if the chat is a group, and I am not the author, then delete the message as an admin
                                if ((0, WABinary_1.isJidGroup)((_a = content.delete) === null || _a === void 0 ? void 0 : _a.remoteJid) && !((_b = content.delete) === null || _b === void 0 ? void 0 : _b.fromMe)) {
                                    additionalAttributes.edit = '8';
                                }
                                else {
                                    additionalAttributes.edit = '7';
                                }
                            }
                            return [4 /*yield*/, relayMessage(jid, fullMsg_1.message, { messageId: fullMsg_1.key.id, cachedGroupMetadata: options.cachedGroupMetadata, additionalAttributes: additionalAttributes })];
                        case 4:
                            _c.sent();
                            if (config.emitOwnEvents) {
                                process.nextTick(function () {
                                    processingMutex.mutex(function () { return (upsertMessage(fullMsg_1, 'append')); });
                                });
                            }
                            return [2 /*return*/, fullMsg_1];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        } });
};
exports.makeMessagesSocket = makeMessagesSocket;
